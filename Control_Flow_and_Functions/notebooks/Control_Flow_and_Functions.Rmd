---
title: "Introduction to Programming with R"
subtitle: "Control Flow and Functions"
author: "Selene R. Schmittling"
date: "2025-08-01" 
output: 
  html_document: 
    number_sections: true
  pdf_document:
editor_options: 
  chunk_output_type: inline
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Learning Outcomes

In this Session of our R Workshop, we will cover the following introductory aspects of R Studio & Programming:

-   Conditional and Flow Control Statements
    -   if
    -   for
    -   while
-   Functions, including
    -   built-in
    -   library
    -   user-defined
-   Getting help
-   File Input and Output

By the end of this Session, you will understand:

1.  How to write an if statement and what to use it for
2.  How to write a for loop, how it works and what to use if for
3.  How to write a while loop, how it works and what to use it for
4.  The three types of functions
5.  The anatomy of a function
6.  How to install and use R Libraries
7.  How to use documentation, get help in RStudio
8.  How to import and save data

## Conditional Statements and Flow Control

### If Statement (Conditional)

The `if` statement allows us to run code based on some condition (**if** the condition is true, the code is run). The `if` statement can use a logical variable or an expression that evaluates to a logical value as its "test". Here is what it looks like:

```{r if-statement}
eatsHamburger = TRUE
eatsVegees = TRUE
eatsMeat = TRUE
numHamburgersEaten = 1 # number per week
my.calorie.count <- 0


# Use relational operator
if (numHamburgersEaten <= 1) {
  eatsHamburger = TRUE
}

# Use a logical operator
if (eatsVegees==TRUE && eatsMeat==FALSE) {
  # I'm a vegetarian
  eatsHamburger = FALSE
}

# Use logical variable
if (eatsHamburger) {
  my.calorie.count <- my.calorie.count + 650
}
```

You use if statements when you want to execute code **conditionally**, e.g. only if certain conditions are met.

We can expand the `if` statement with `else`. The `else` clause is used to run code if the condition **isn't** met. Let's look at some examples:

```{r if-else-statement}
eatsHamburger = TRUE
eatsVegees = TRUE
eatsMeat = TRUE
numHamburgersEaten = 1 # number per week
my.calorie.count <- 0

# increase calorie count
if (eatsHamburger) {
  my.calorie.count <- my.calorie.count + 650
} else {
  my.calorie.count <- my.calorie.count + 60 # I should choose this more often
}

# make sure you have open ({) and closed (}) braces! Let's remove one and see what R does. Also note, if you put your cursor after a brace (or a bracket for that matter) it will highlight it's match.

```

While we have provided examples with one line of code, you can put as much code between the two braces as you need.

### For Loop

A `for` loop is used to perform code multiple times. The code in a `for` loop will, by definition, run a specified number of times. This is because you provide a range, in some form, over which the loop executes. This makes `for` loops very useful for traversing data structures like vectors, matrices, and dataframes. Let's look at some examples:

```{r for-loops}
# Simplest example
for (i in 1:5) {
  print(i) # spice it up and divide i by 2
}

vector1 = c("one", "two", "three", "four", "five")
for (x in vector1) {
  print(x)
}

vector2 = c(2, 4, 6, 8, 10)
for (y in vector2) {
  print(y)
}
```

In the last couple of examples, we looped over a vector. What about a matrix? In this case we would do nested `for` loops.

```{r nested-for}
# Make a matrix
data = (1:60)
my.matrix = matrix(data, nrow=10, ncol=6, byrow = TRUE)
print(my.matrix)

# Lets print every value in the matrix out one at a time
# REMEMBER TO MAKE SURE YOU HAVE OPEN & CLOSED BRACES!
for (row in 1:10) {
  for (col in 1:6) {
    print(my.matrix[row,col])
  }
}

# We can use functions to extract number of rows and cols
for (row in 1:nrow(my.matrix)) {
  for (col in 1:ncol(my.matrix)) {
    print(my.matrix[row,col])
  }
}

# How would you use this same kind of structure to access data in a 3-D array?


```

### While Loops

While loops execute code by testing a condition. This means that the code may execute once, several times or not at all! While loops are great when you need to perform some tasks, but you don't know how many times. Humans do this all the time, "I want to pet my dog until the dog hair on my pants makes them look like fur leggings." You don't know when that condition will happen, but when it does you want to stop petting your dog.

While `for` loops execute over a range of values, `while` loops need a condition to test. This means you use a logical variable, relational expression or logical expression to determine if the code should run. Here are some examples:

```{r while-loop}

# While loop
numBurgersEaten <- 0
while (eatsHamburger == TRUE) {
  my.calorie.count <- my.calorie.count + 650
  numBurgersEaten <- numBurgersEaten + 1
}

# Ok, let's try this again
numBurgersEaten <- 0
while (eatsHamburger == TRUE) {
  my.calorie.count <- my.calorie.count + 650
  numBurgersEaten <- numBurgersEaten + 1
  if (numBurgersEaten > 5) {
    eatsHamburger == FALSE # OK we've added code to change value of condition
  }
}

```

You are just starting out, but let's talk about efficiency when you are writing code. There will be many ways to write code. Good code is

-   code that works and

-   that can be understood by others.

Once you are good at that, and as your experience grows, you will work on efficient. Efficiency comes with practice and in exploring different ways to write the same code.\
\
Let's look at how we might make the code above more efficient.

```{r more-efficient-while}

# Ok, let's look at the previous code
numBurgersEaten <- 0
while (eatsHamburger == TRUE) {
  my.calorie.count <- my.calorie.count + 650
  numBurgersEaten <- numBurgersEaten + 1
  if (numBurgersEaten > 5) { 
    eatsHamburger == FALSE # OK we've added code to change value of condition
  }
}

# Walk through the steps in your head. Is there anything that seems duplicative? Focus on the "if" statement used above to change the value of "eatsHamburger".

# What if we just use numBurgersEaten as our "while" test?
# How you you rewrite it to use that instead?

numBurgersEaten <- 0
while (numBurgersEaten <= 5) {
  my.calorie.count <- my.calorie.count + 650
  numBurgersEaten <- numBurgersEaten + 1
}
```

Some important considerations with `while` loops is that you need to ensure:

-   you initialize any values used inside the loop to change the condition BEFORE the while loop starts

-   that the condition used to determine whether the while loop is run again is updated within the while loop

### I digress ...

Sometimes you need to exit an `if`, `for`, or `while` loop before all the code is executed. Most languages, including R, have a reserved word you can use to exit a loop, if needed. This word is `break`. While we won't cover it today, it is an important enough concept that I want to provide an example.

```{r breaking-out}
# Use a for loop as an example, but this will work with if and while statements too

for (i in 1:10) {
  print(paste("Current value:", i))
  
  # if value = 7 print a different message and exit loop
  if (i == 7) {
    print("Elvis has left the building. Bye!")
    break # this statement will end the loop change 7 to another number
  }
}

```

## Functions

We will look at three types of functions:

-   Built-in

    -   are available when R loads without further info

-   External package functions

    -   need to be initially installed

    -   when you want to use them you must load them using the `library()` command

-   User-defined functions

We'll talk about each of these and explore some examples. The following vocabulary will be helpful:

> **define**: before they can be used, functions need to be defined. For built-in and external package functions this will already be done for you (sweet!!). However, as the name suggests when you create your own functions (user-defined) you will "define" the function
>
> **call**: when you use a function in your program you "call" it.

A function has three main components:

-   name (so you can refer to it because "hey, you!" won't get its attention)

-   parameters

    -   pieces of information the function needs to do it's job.

    -   parameters can be required or optional

        -   the function won't run without required parameters

        -   optional parameters will have a default value which is used if no value is passed for it

        -   the term parameters refers to the variables the function needs to do its job.

        -   when we provide values for those parameters, we call them arguments.

-   return value

    -   this is a value that the function returns when it's done
    -   frequently we will store this value in a variable using the assignment operator
    -   the return value may be
        -   a value that was calculated
        -   data that has been manipulated in some way, or
        -   a status that indicates whether the function encountered any errors

### Built-In

Built-in functions are functions that are loaded when R is loaded. You don't have to do anything to use them.

You can see what packages R loads by opening the Packages tab in the Output pane. If you haven't loaded any packages, then the packages with check-marks are the built-in packages that get loaded.

We saw an example of using built-in package in the Basic Syntax and Operators Workshop.

```{r built-in-function-call}


```
