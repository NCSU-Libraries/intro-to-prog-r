---
title: "Introduction to Programming with R"
subtitle: "Control Flow and Functions"
author: "Selene R. Schmittling"
date: "2025-08-01" 
output: 
  html_document: 
    number_sections: true
  pdf_document:
editor_options: 
  chunk_output_type: inline
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Learning Outcomes

In this Session of our R Workshop, we will cover the following introductory aspects of R Studio & Programming:

-   Conditional and Flow Control Statements
    -   if
    -   for
    -   while
-   Functions, including
    -   built-in
    -   library
    -   user-defined
-   Getting help
-   File Input and Output

By the end of this Session, you will understand:

1.  How to write an if statement and what to use it for
2.  How to write a for loop, how it works and what to use if for
3.  How to write a while loop, how it works and what to use it for
4.  The three types of functions
5.  The anatomy of a function
6.  How to install and use R Libraries
7.  How to use documentation, get help in RStudio
8.  How to import and save data

## Conditional Statements and Flow Control

### If Statement (Conditional)

The `if` statement allows us to run code based on some condition (**if** the condition is true, the code is run). The `if` statement can use a logical variable or an expression that evaluates to a logical value as its "test". Here is what it looks like:

```{r if-statement}
eatsHamburger = TRUE
eatsVegees = TRUE
eatsMeat = TRUE
numHamburgersEaten = 1 # number per week
my.calorie.count <- 0


# Use relational operator
if (numHamburgersEaten <= 1) {
  eatsHamburger = TRUE
}

# Use a logical operator
if (eatsVegees==TRUE && eatsMeat==FALSE) {
  # I'm a vegetarian
  eatsHamburger = FALSE
}

# Use logical variable
if (eatsHamburger) {
  my.calorie.count <- my.calorie.count + 650
}
```

You use if statements when you want to execute code **conditionally**, e.g. only if certain conditions are met.

We can expand the `if` statement with `else`. The `else` clause is used to run code if the condition **isn't** met. Let's look at some examples:

```{r if-else-statement}
eatsHamburger = TRUE
eatsVegees = TRUE
eatsMeat = TRUE
numHamburgersEaten = 1 # number per week
my.calorie.count <- 0

# increase calorie count
if (eatsHamburger) {
  my.calorie.count <- my.calorie.count + 650
} else {
  my.calorie.count <- my.calorie.count + 60 # I should choose this more often
}

# make sure you have open ({) and closed (}) braces! Let's remove one and see what R does. Also note, if you put your cursor after a brace (or a bracket for that matter) it will highlight it's match.

```

While we have provided examples with one line of code, you can put as much code between the two braces as you need.

### For Loop

A `for` loop is used to perform code multiple times. The code in a `for` loop will, by definition, run a specified number of times. This is because you provide a range, in some form, over which the loop executes. This makes `for` loops very useful for traversing data structures like vectors, matrices, and dataframes. Let's look at some examples:

```{r for-loops}
# Simplest example
for (i in 1:5) {
  print(i) # spice it up and divide i by 2
}

vector1 = c("one", "two", "three", "four", "five")
for (x in vector1) {
  print(x)
}

vector2 = c(2, 4, 6, 8, 10)
for (y in vector2) {
  print(y)
}
```

In the last couple of examples, we looped over a vector. What about a matrix? In this case we would do nested `for` loops.

```{r nested-for}
# Make a matrix
data = (1:60)
my.matrix = matrix(data, nrow=10, ncol=6, byrow = TRUE)
print(my.matrix)

# Lets print every value in the matrix out one at a time
# REMEMBER TO MAKE SURE YOU HAVE OPEN & CLOSED BRACES!
for (row in 1:10) {
  for (col in 1:6) {
    print(my.matrix[row,col])
  }
}

# We can use functions to extract number of rows and cols
for (row in 1:nrow(my.matrix)) {
  for (col in 1:ncol(my.matrix)) {
    print(my.matrix[row,col])
  }
}

# How would you use this same kind of structure to access data in a 3-D array?


```

### While Loops

While loops execute code by testing a condition. This means that the code may execute once, several times or not at all! While loops are great when you need to perform some tasks, but you don't know how many times. Humans do this all the time, "I want to pet my dog until the dog hair on my pants makes them look like fur leggings." You don't know when that condition will happen, but when it does you want to stop petting your dog.

While `for` loops execute over a range of values, `while` loops need a condition to test. This means you use a logical variable, relational expression or logical expression to determine if the code should run. Here are some examples:

```{r while-loop}

# While loop
numBurgersEaten <- 0
while (eatsHamburger == TRUE) {
  my.calorie.count <- my.calorie.count + 650
  numBurgersEaten <- numBurgersEaten + 1
}

# Ok, let's try this again
numBurgersEaten <- 0
while (eatsHamburger == TRUE) {
  my.calorie.count <- my.calorie.count + 650
  numBurgersEaten <- numBurgersEaten + 1
  if (numBurgersEaten > 5) {
    eatsHamburger == FALSE # OK we've added code to change value of condition
  }
}

```

You are just starting out, but let's talk about efficiency when you are writing code. There will be many ways to write code. Good code is

-   code that works and

-   that can be understood by others.

Once you are good at that, and as your experience grows, you will work on efficient. Efficiency comes with practice and in exploring different ways to write the same code.\
\
Let's look at how we might make the code above more efficient.

```{r more-efficient-while}

# Ok, let's look at the previous code
numBurgersEaten <- 0
while (eatsHamburger == TRUE) {
  my.calorie.count <- my.calorie.count + 650
  numBurgersEaten <- numBurgersEaten + 1
  if (numBurgersEaten > 5) { 
    eatsHamburger == FALSE # OK we've added code to change value of condition
  }
}

# Walk through the steps in your head. Is there anything that seems duplicative? Focus on the "if" statement used above to change the value of "eatsHamburger".

# What if we just use numBurgersEaten as our "while" test?
# How you you rewrite it to use that instead?

numBurgersEaten <- 0
while (numBurgersEaten <= 5) {
  my.calorie.count <- my.calorie.count + 650
  numBurgersEaten <- numBurgersEaten + 1
}
```

Some important considerations with `while` loops is that you need to ensure:

-   you initialize any values used inside the loop to change the condition BEFORE the while loop starts

-   that the condition used to determine whether the while loop is run again is updated within the while loop

### I digress ...

Sometimes you need to exit an `if`, `for`, or `while` loop before all the code is executed. Most languages, including R, have a reserved word you can use to exit a loop, if needed. This word is `break`. While we won't cover it today, it is an important enough concept that I want to provide an example.

```{r breaking-out}
# Use a for loop as an example, but this will work with if and while statements too

for (i in 1:10) {
  print(paste("Current value:", i))
  
  # if value = 7 print a different message and exit loop
  if (i == 7) {
    print("Elvis has left the building. Bye!")
    break # this statement will end the loop change 7 to another number
  }
}

```

## Functions

We will look at three types of functions:

-   Built-in

    -   are available when R loads without further info

-   External package functions

    -   need to be initially installed

    -   when you want to use them you must load them using the `library()` command

-   User-defined functions

We'll talk about each of these and explore some examples. The following vocabulary will be helpful:

> **define**: before they can be used, functions need to be defined. For built-in and external package functions this will already be done for you (sweet!!). However, as the name suggests when you create your own functions (user-defined) you will "define" the function
>
> **call**: when you use a function in your program you "call" it.

A function has three main components:

-   name (so you can refer to it because "hey, you!" won't get its attention)

-   parameters

    -   pieces of information the function needs to do it's job.

    -   parameters can be required or optional

        -   the function won't run without required parameters

        -   optional parameters will have a default value which is used if no value is passed for it

        -   the term parameters refers to the variables the function needs to do its job.

        -   when we provide values for those parameters, we call them arguments.

-   return value

    -   this is a value that the function returns when it's done
    -   frequently we will store this value in a variable using the assignment operator
    -   the return value may be
        -   a value that was calculated
        -   data that has been manipulated in some way, or
        -   a status that indicates whether the function encountered any errors

### Built-In

Built-in functions are functions that are loaded when R is loaded. You don't have to do anything to use them.

You can see what packages R loads by opening the Packages tab in the Output pane. If you haven't loaded any other packages, then the packages with check-marks are the built-in packages that get loaded.

We saw an example of using built-in package in the Basic Syntax and Operators Workshop.

```{r built-in-function-call}
# define some data
data <- data.frame(a = c(72,41,54,36), b=c('East','West','North','South'))

# generate plot
barplot(data$a, 
        names.arg = data$b, 
        col="blue", 
        ylab="# of Regional Managers")

```

The `barplot()` function is part of Base R and is loaded by default. In the console window, type "?barplot" and hit enter. Let's use the vocabulary we covered earlier and read some documentation!

Here is what we see in the Help pane:

-   name of the function and the package it is in: barplot {package}

-   title of the help page: Bar Plots

-   Description: gives a high-level description of what the function does

-   Usage:

    -   provides the function interface

        -   all parameters, required and optional

            -   optional parameters will be followed by an "=" sign

        -   different "flavors" of the function

-   Arguments

    -   lists all parameters

    -   sometimes indicates "optional", but not always

    -   includes acceptable values, data types and data structures

-   Value

    -   provides information about the return value

-   Authors, References, See Also and Examples

    -   self-explanatory

    -   click on "Run examples"

```{r function-flavors-and-return-values}
# using barplot() S3 Method for class `formula`
# define some data
data <- data.frame(a = c(72,41,54,36), b=c('East','West','North','South'))

# generate plot
barplot(a ~ b, 
        data = data, 
        col="blue", 
        ylab="# of Regional Managers")

bp <- barplot(a ~ b, 
        data = data, 
        col="blue", 
        ylab="# of Regional Managers")

```

### Practice Using Built-In Functions

```{r built-in-practice}
# Make some data to plot. Uses rnorm() to generate 50 values drawn from a normal distribution with a mean of 0 and standard deviation of 4.25
data <- rnorm(50, mean=0, sd=4.25)

# You can use the function built in function hist() to create a histogram of data
# Use ?hist() in the Console to learn how to call the function

# What are the required parameters? Call the function using only the required parameter
hist(data)

# add a breaks statement to increase the number of bars (bins)
# hint: count the bars in the last plot and increase it
hist(data, breaks=15)

# set the freq argument to TRUE and then FALSE and look at the difference
hist(data, breaks=15, freq=TRUE)
hist(data, breaks=15, freq=FALSE)
```

### Packages

The Base R packages provide a lot of functionality and they will take you far. However, the beauty of open source languages is that creative, capable people like you can create packages and provide them to you. The ability to expand R's functionality is limitless and free.

Packages:

-   must be installed initially

-   once installed, they must be loaded using the `library()` function

    -   the function will stay loaded as long as the R-session is active and not closed.

    -   if the R session is closed (you exit out of R), you will need to run the `library()` command again

Let's explore a package that will be useful for importing data: `openxlsx2`.

For this we will work in the Package's tab of the Output pane. Do the following:

1.  In the output pane, click on the Packages tab.
2.  Click on Install
3.  Type the name of the package: "openxlxs2" and hit enter

This will installs the package in your environment.

Next:

1.  Scroll through the list of packages in the Packages pane and look for "openxlsx2".
2.  Start typing "openxlsx2" in the search bar to find it quicker.
3.  Is there a check in the box to the left of the name?
    -   Yes: the library is already loaded.
        -   Uncheck it, so we can load it
    -   No: then we need to load it before we use it.

```{r load-a-package}
library(openxlsx2)

# load NCSU Mascot data using openxlsx2
# Because we are in a notebook it sees the current working directory as "notebooks"
# To use a relative file name, we use "../" to "go" up a level and then "/data/" 
# points to documents in the data directory. Once that is entered if we hit Tab we will get a list of files to choose from.

# Load data using read_xlsx() function
mascot.data <- read_xlsx("../data/NCSU_Mascots_v1.xlsx")
# print the first 6 rows of the data using the head() function
print(head(mascot.data))
```

While we are using this package, let's practice writing data to an excel file.

```{r write-to-excel}



```

### User-defined Functions

Functions, whether built-in, from packages or those you write yourself (user-defined) should perform a discrete task or set of tasks. These task should be well-defined
